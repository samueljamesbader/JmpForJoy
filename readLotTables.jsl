// Use the local namespace
Names Default To Here(1);

// Generates a horizontal data table for select parameters from which the variability report can be generated.
ReadLotTables=Function({run},{Default Local},
	
	// Open the limits table, keeping it private (unaccessible)
	// In fact, all tables opened in this script will be private except the final
	// one used in drawing the report.
	// Also, save the path to limits for later.
	::rundicts[run]["dtLimits path"]=
		::limsource||::rundicts[run]["limitstable"]||".limits.jmp";
	dtLimits=Open(::rundicts[run]["dtLimits path"],Private);
	
	// If whichparams is empty, show a pop-up to determine what to analyze
	If(not(N Items(::rundicts[run]["whichparams"])),
	
		// The list of parameters is obtained from the limits table
		all params=column(dtLimits,"Parameter")<<Get Values;
		
		// Create the pop-up window, with a vertical list layout
		New Window(<<Modal,
			VListBox(
			
			// Which parameters to use (list box of all params)
			whichparambox=ListBox(all params)
			
			// Whether it's a special analysis (checkbox)
			,specialanalysisbox=CheckBox("Special Analysis",
				<<Set(::rundicts[run]["specialanalysis"]))
				
			// Whether to split center and edge (checkbox)
			,CEbox=CheckBox("Separate Center/Edge",
				<<Set(::rundicts[run]["centeredge"]))
			)
		);
		
		// Once the pop-up closes, read the user's inputs into rundicts
		::rundicts[run]["whichparams"]=whichparambox<<Get Selected;
		::rundicts[run]["specialanalysis"]=specialanalysisbox<<Get();
		::rundicts[run]["centeredge"]=CEbox<<Get();
	);
	
	// We'll be using whichparams a lot--let's give it a short name
	whichparams=::rundicts[run]["whichparams"];
	
	// If user made no selection in the pop-up, then stop!
	// And clear this entry from rundicts.
	if(not(N Items(whichparams)),
		Write("No parameters selected.\!N");
		::rundicts[run]=.;
		Stop();
	);
	
	
	
	// List all the files in the clean source folder
	pattern="("||source||")_("||project||")_("||lot||")_("||date||").jmp";
	all files=Files in Directory(::cleansource);
	
	// Pick out only the relevant ones for our query
	For(f=1,f<=Length(all files),f++,
		mo=Regex Match(all files[f],pattern);
		If(Length(mo),
		
			// Open the table and take just the necessary columns
			cur dt=Open(::cleansource||mo[1],Private);
			column(cur dt,"WAFER") << Set Selected(1);
			column(cur dt,"XCOORD") << Set Selected(1);
			column(cur dt,"YCOORD") << Set Selected(1);
			For(p=1,p<=Length(whichparams),p++,
				Column(cur dt,whichparams[p])<<Set Selected(1));
			subs=cur dt << Subset(Selected Columns,Private);
			
			// Add and fill a LOT column and a DATE column and a PCM_SPEC column
			subs<<new column("PCM_SPEC",Character,<<Set Each Value(mo[3]));
			subs<<new column("LOT_ID",Character,<<Set Each Value(mo[4]));
			subs<<new column("DATE",Character,<<Set Each Value(mo[5]));
			Close(cur dt, No Save);
			
			// Concatenate into one vertical table ("dt") for the entire query
			If(Is Empty(dt),
				dt=subs;
				,				
				dt<<Concatenate(subs,Append To First Table);
				Close(subs,NoSave);
			);
		);
	);

	// Gather the limits from the limits table into rundicts.
	// (This is also where we do the value invert if necessary.)
	Write("Adding Spec Limits\!N");
	
	// Iterate through rows of the limits table
	For(r=1,r<N Rows(dtLimits),r++,
	
		// If the parameter name in this row is in whichparams...
		param=Column(dtLimits,"PARAMETER")[r];
		If(Contains(whichparams,param),
		
			// Create an entry for this parameter in rundicts
			::rundicts[run]["pdict"][param]=Associative Array();
			
			// Read the axis values
			scale= Column(dtLimits,"AXIS_SCALE")[r];
			lal= Column(dtLimits,"AXIS_LOW")[r];
			ual= Column(dtLimits,"AXIS_HIGH")[r];
			inc= Column(dtLimits,"AXIS_INC")[r];
			
			// If axis limits are missing...
			If(Is Missing(lal)|Is Missing(ual),
			
				// Create an invisible statistics table for this parameter's data
				eval(eval expr(
					t=dt<<Tabulate(
						Show Control Panel( 0 ),
						Add Table(
							Column Table( Analysis Columns( expr(column(dt,param) ) ) ),
							Row Table( Statistics( Median, Interquartile Range, Min ) )
						),
						<<MakeIntoDataTable(Invisible(1),OutputTable("Stats"))
					)));
				
				// Read out the median, interquartile range, and min
				// then close the stats table and window
				med=Column(DataTable("Stats"),param)[1];
				iqr=Column(DataTable("Stats"),param)[2];
				dmin=Column(DataTable("Stats"),param)[3];
				t<<Close Window();
				Close("Stats",NoSave);
				
				// Calculate some reasonable and round axis values, roughly median+/-3 interquartile ranges.
				order of magnitude inc=10^Round(Log10(iqr));
				inc=Round(iqr/order of magnitude inc)*order of magnitude inc;
				lal=Floor((med-3*iqr)/inc)*inc;
				ual=Ceiling((med+3*iqr)/inc)*inc;
				
				// If there was a problem with that, then don't bother trying to make the values round.
				If(Is Missing(inc),
					lal=med-3*iqr;
					ual=med+3*iqr;
					inc=(ual-lal)/7;
				);
				
				// If all the data is positive, don't let the lower limit be negative
				lal=If(dmin>0, Max(lal,0),lal);
				
			);
			
			// If the limits table says the data should be inverted
			valinv=Column(dtLimits,"VALUE_INVERT")[r];
			If (valinv,
			
				// Then flip the data in this column, and read in the spec limits flipped.
				Column(dt,param)<< Set Values(-1*(Column(dt,param)<<Get Values));
				lsl = -Column( dtLimits, "SPEC_HIGH" )[r];
				usl = -Column( dtLimits, "SPEC_LOW" )[r];
				,
				// Else just read the spec limits in normally.
				lsl = Column( dtLimits, "SPEC_LOW" )[r];
				usl = Column( dtLimits, "SPEC_HIGH" )[r];
			);
			
			// Read in the default data filter limits.
			lvl= Column(dtLimits,"VALID_LOW")[r];
			uvl= Column(dtLimits,"VALID_HIGH")[r];
			
			// If the data filter limits are invalid, set to missing.
			If(lvl>=uvl, lvl=.;uvl=.);
			
			// Read in the extra axis details
			mt= Column(dtLimits,"MINOR_TICKS")[r];
			format= Column(dtLimits,"FORMAT")[r];
			
			// Put all of the above into the dictionary for this parameter
			::rundicts[run]["pdict"][param]["LSL"]=lsl;
			::rundicts[run]["pdict"][param]["USL"]=usl;
			::rundicts[run]["pdict"][param]["LAL"]=lal;
			::rundicts[run]["pdict"][param]["UAL"]=ual;
			::rundicts[run]["pdict"][param]["INC"]=inc;
			::rundicts[run]["pdict"][param]["SCALE"]=scale;
			::rundicts[run]["pdict"][param]["LVL"]=lvl;
			::rundicts[run]["pdict"][param]["UVL"]=uvl;
			::rundicts[run]["pdict"][param]["MT"]=mt;
			::rundicts[run]["pdict"][param]["FORMAT"]=format;
			::rundicts[run]["pdict"][param]["VALINV"]=valinv;
			
			// Also record the row number so we remember where to save the limits later
			::rundicts[run]["pdict"][param]["row"]=r;
		);
	);
	
	// Open the Excel file of splits if it exists
	splits file=::rundicts[run]["splitsfile"];
	If(file exists(splits file),
		Write("Found splits file.\!N");
		splittab=Open(
			splits file,
			Open all sheets(1),
			Use for all sheets( 1 ),
			Concatenate Worksheets( 0 ),
			Create Concatenation Column( 0 ),
			Worksheet Settings(
				1,
				Has Column Headers( 1 ),
				Number of Rows in Headers( 1 ),
				Headers Start on Row( 1 ),
				Data Starts on Row( 2 ),
				Data Starts on Column( 1 ),
				Data Ends on Row( 0 ),
				Data Ends on Column( 0 ),
				Replicated Spanned Rows( 1 ),
				Suppress Hidden Rows( 1 ),
				Suppress Hidden Columns( 1 ),
				Treat as Hierarchy( 0 )
			)//,
			//Private
		);

		// Check to see if it's missing the columns we need for matching...
		splittab columns=splittab<<Get Column Names;
		full lot col num=contains(splittab columns,As Name("Full Lot"));
		wafer col num=contains(splittab columns,As Name("Wafer"));
		
		if( not(full lot col num &  wafer col num),
		
			// If so, let the user know
			Write("Splits table incorrectly formatted!\!N");,
			
			// Otherwise proceed to merge the tables, and close the component tables
			Column(splittab,"Full Lot")<<Set Name("LOT_ID");
			Column(splittab,"Wafer")<<Set Name("WAFER");
			splittab<<Delete Column(Base Lot);
			//Stop();
			fulltab=dt << Join(
					With(splittab),
					By Matching Columns(:LOT_ID = :LOT_ID, :WAFER = :WAFER),
					Merge Same Name Columns,
					Preserve Main Table Order(1),
					Suppress Formula Evaluation(1),
					Include Non Matches(1,0),
					Output Table Name("Joined Horizontal, Run" || Char(run) ),
					Invisible
			);
			Close(dt, No Save);
			Close(splittab, No Save);
		);
		,
		// Otherwise, if not splits file found, inform the user.
		Write("Didn't find splits file.  Proceeding without.\!N");
		fulltab=dt;
		fulltab<<Set Name("Joined Horizontal, Run" || Char(run) );
	);
	
	// We're about to make a bunch of tweaks to the table, so let's warn JMP
	// not to do any intermediate processing (like evaluating formulas)
	// on this table until we're finished!
	fulltab << Begin Data Update;
	
	// Create a character column by concatenating the coordinates.
	// This column will be used in a look-up to determine whether we are center or edge,
	// and will be the "Shape Name Use" column if we want to plot on a wafer map.
	eval(eval expr(fulltab << New Column("Coord_CAT", Character,Formula(Char(:XCOORD) || "_" || Char(:YCOORD)),
		Set Property(
			"Map Role", Map Role(Shape Name Use(
				expr(::scriptdir || "wafermaps\" || wafermap || "-Name.jmp"),
				"COORDS")))
	)));
	
	
	// Get the center-edge look-up dictionary for this wafermap
	include("mapCenterEdge.jsl");
	ce map=::CE Maps[wafermap] ;
	
	// Make a new column which just states "center" or "edge" based on the previous column
	eval( eval expr(
		fulltab<< New Column("ColorMap", Character, Nominal,
			Formula(if(expr(ce map)[:Coord_CAT],"Edge","Center")))));
	
	// Use that new column to color the rows
	(fulltab << Select Where( :ColorMap == "Center"))<<Colors("Red");
	(fulltab << Select Where( :ColorMap == "Edge"))<<Colors("Blue");
	fulltab << Clear Select;
	
	// For each parameter
	For( p=1, p<=N Items(whichparams),p+=1,
		colname=whichparams[p];
		
		// Create a copy of the parameter column that only has values for center sites
		center formula = eval expr( if(:ColorMap=="Center",ascolumn(expr(colname)),.));
		fulltab << New column(
			colname||" center";,
			Formula(nameexpr(center formula))
		);
		
		// Create a copy of the parameter column that only has values for edge sites
		edge formula = eval expr( if(:ColorMap=="Edge",ascolumn(expr(colname)),.));
		fulltab << New column(
			colname||" edge",
			Formula(nameexpr(edge formula))
		);
	);
	
	// Create the relevant columns for the failure chart
	Write("Creating Failure columns...\!N");
	
	// For each parameter
	For( p=1, p<=N Items(whichparams), p+=1,
		colname=whichparams[p];
				
		// The failbool column: boolean formula, 1 if failure
		failbool_colname=colname||"_FAILBOOL";
		eval(eval expr(fulltab << New Column(
			failbool_colname,
			Formula(
				( ascolumn(expr(colname)) < ::rundicts[expr(run)]["pdict"][expr(colname)]["LSL"])
				|
				( ascolumn(expr(colname)) > ::rundicts[expr(run)]["pdict"][expr(colname)]["USL"]) 	
			)
		)));
		
		// failbool, but only for centers
		eval(eval expr(fulltab << New Column(
			failbool_colname||" center",
			Formula(if(:ColorMap=="Center",ascolumn(expr(failbool_colname)),.))
		)));
		
		// failbool, but only for edges
		eval(eval expr(fulltab << New Column(
			failbool_colname||" edge",
			Formula(if(:ColorMap=="Edge",ascolumn(expr(failbool_colname)),.))
		)));
		
		// The failpct column:
		// failure proportion formula calculated by averaging the boolean column
		// over rows that have the same wafer, lot_id, and pcm_spec.
		failpct_colname=colname||"_FAILPCT";
		eval(eval expr(fulltab << New Column(
			failpct_colname,
			Formula(col mean(ascolumn(expr(failbool_colname)),:WAFER, :LOT_ID, :PCM_SPEC))
		)));
		
		// failpct, but only for centers
		eval(eval expr(fulltab << New Column(
			failpct_colname||" center",
			Formula(col mean(ascolumn(expr(failbool_colname||" center")),:WAFER, :LOT_ID, :PCM_SPEC))
		)));
		
		// failpct, but only for edges
		eval(eval expr(fulltab << New Column(
			failpct_colname||" edge",
			Formula(col mean(ascolumn(expr(failbool_colname||" edge")),:WAFER, :LOT_ID, :PCM_SPEC))
		)));
	);
	
	// Create a NUMERIC date column by parsing the preexisting character Date column
	// So that the lots can be ordered by this numeric value on the x-axis
	fulltab << New Column("numeric date", Numeric, Continuous, Format("Best", 12),
		Formula(Parse Date(:DATE, "m/d/y")));
	
	// Run those formulas now
	// And let JMP know we're done tweaking the table
	fulltab << RunFormulas();
	fulltab << End Data Update;
	
	// Store references to these tables in rundicts for later
	::rundicts[run]["htab"]=fulltab;
	::rundicts[run]["dtLimits"]=dtLimits;
			
	// All done!
	Write("Done generating horizontal table.\!N");
);