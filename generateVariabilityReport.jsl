// Creates the graphical window showing the variability report
// htab- the table to work from
// params- list of parameter names
// isspecial- whether the analysis is varied or just normal x-y
// dtLimits- the limits table

generateVariabilityReport=Function({htab,params,isspecial,dtLimits},{Default Local},

	// Use the next empty slot in pdicts
	rno=N Items(::pdicts)+1;
	::pdicts[rno]=Associative Array();
	::pdicts[rno]["htab"]=htab;
	
	// If special analysis, then open a column dialog for the user to vary the analysis
	If(isspecial,
		// Give the usual variables as default
		cd = Column Dialog(
			xvars = ColList("X Variables",Columns(:WAFER)),
			xgroupers =  ColList("X Grouping",Columns(:PCM_SPEC, :LOT_ID)),
		);
		xvars=cd["xvars"];
		xgroupers=cd["xgroupers"];
		,
		// If not special, just use those defaults
		xvars= List(:WAFER);
		xgroupers= List(:PCM_SPEC, :LOT_ID);
	);
	// Create the window
	win=New Window("Variability", vb=V List Box());

	// Just setting a default used in graphical limit adjustment code
	::up=0;
	
	// For each parameter
	For( p=1, p<=N Items(params), p+=1,	
	
		// Names
		colname=params[p];
		fail_colname=Concat(colname,"_FAILPCT");
		
		//Create an entry in pdicts for this parameter
		::pdicts[rno][colname]=Associative Array();
		
		// Store spec limits in pdicts
		::pdicts[rno][colname]["LSL"]=(column(htab,colname) << get property("spec limits"))["LSL"];
		::pdicts[rno][colname]["USL"]=(column(htab,colname) << get property("spec limits"))["USL"];
		
		// Create an expression for the graphical limit adjustment code
		// I can't explain the black magic that makes this section work most of the time.
		// Might revisit, but I've tried so many things already... there's definitely some sort of
		// race condition in JMP...
		::pdicts[rno][colname]["script"]=eval expr(
			Handle( .5, ::pdicts[expr(rno)][expr(colname)]["LSL"],
				if(::up,print("doing nothing");::up=0;Stop();,
					::pdicts[expr(rno)][expr(colname)]["lslbox"]<<set(y);
					lslboxChanged(expr(colname),expr(rno));
				);,
				::up=1;
				reSpec(expr(colname),expr(rno));
				::up=0;
			);
			Handle( .5,::pdicts[expr(rno)][expr(colname)]["USL"],
				if(::up,print("doing nothing");::up=0;Stop();,
					::pdicts[expr(rno)][expr(colname)]["uslbox"]<<set(y);
					uslboxChanged(expr(colname),expr(rno));
				);,
				::up=1;
				reSpec(expr(colname),expr(rno));
				::up=0;
			);
		);
		
		// Format the (possible varied) x and y variables into the form that graph builder needs them
		varexpr=expr(Variables());
		for(i=1, i<=n items(xvars),i+=1,
			insertinto(varexpr,
				eval expr( X(expr(xvars[i]),Position(1)))
			)
		);
		insertinto(varexpr,
			eval expr(Y(column(htab,expr(fail_colname))))
		);
		insertinto(varexpr,
			eval expr(Y(column(htab,expr(colname))))
		);
		// Noting that LOT_ID and PCM_SPEC should be chronologically ordered
		for(i=1, i<=n items(xgroupers), i+=1,
			if( Or((xgroupers[i]<<Get Name)=="LOT_ID",(xgroupers[i]<<Get Name)=="PCM_SPEC"),
				insertinto(varexpr,
					eval expr(Group X(expr(xgroupers[i]),
						Order By( :TheDate, Ascending, Order Statistic( "Mean" ) ),
						Show Title( 0 ) ))),
				insertinto(varexpr,
					eval expr(Group X(expr(xgroupers[i])))))
		);
		varexprexpr=expr(nameexpr(varexpr));
		
		// Create an expression to actually build the graph
		vargraph=eval expr(
			Graph Builder(
				Size( 850, 590 ),
				Show Control Panel( 0 ),
				Show Legend( 0 ),
				X Group Edge( "Bottom" ),
				expr(varexprexpr),
				Relative Sizes( "Y", [1 3] ),
				Elements(
					Position( 1, 1 ),
					Line(
						X( 1 ),
						X( 2 ),
						X( 3 ),
						Y,
						Legend( 8 ),
						Row order( 0 ),
						Summary Statistic( "Mean" )
					)
				),
				Elements(
					Position( 1, 2 ),
					Points( X( 1 ), X( 2 ), X( 3 ), Y, Legend( 1 ), Jitter( 1 ) ),
					Box Plot(
						X( 1 ),
						X( 2 ),
						X( 3 ),
						Y,
						Legend( 6 ),
						Jitter( 1 ),
						Outliers( 1 ),
						Box Style( "Outlier" )
					)
				),
				SendToReport(
					Dispatch(
						{},
						expr(fail_colname),
						ScaleBox,
						{Format( "Percent", 10, 0 ), Min( 0 ), Max( 1 ), Inc( 0.1 ),			// Failure range for Jo-ey
						Minor Ticks( 1 ), Show Major Grid( 1 ), Show Minor Ticks( 0 ), Inside Ticks( 1 )}
					),
					Dispatch( {}, "400", LegendBox, {Position( {-1, -1, -1} )} ),
					Dispatch( {}, "Y title", TextEditBox, {Set Text( "Failure rate" )} ),
					Dispatch( {}, "graph title", TextEditBox, {Set Text( "Variability Plot" )} ),
				)
			)
		);

		// Build the graph and store a reference to it in pdicts
		eval(eval expr(vb<<append(::pdicts[rno][colname]["graph"]=expr(name expr(vargraph)))));
		
		// Add in the three buttons
		(::pdicts[rno][colname]["graph"]<<report())<<append(guibox=HListBox());
		eval(evalexpr(guibox<<append(slob=OutlineBox("Spec Limits",
			{"Recalc CPK",UpdateCPKrow(expr(colname),expr(rno))},
			<<OutlineCloseOrientation(Horizontal)))));
		
		slob<<append(buthb=H List Box(Align(Center)));
		eval(eval expr(buthb<<append(ButtonBox("Activate Sliders",
			((::pdicts[expr(rno)][expr(colname)]["graph"]<<report)[Frame Box (2)])<<remove graphics script(1);
			((::pdicts[expr(rno)][expr(colname)]["graph"]<<report)[Frame Box (2)])<<add graphics script(
				expr(::pdicts[rno][colname]["script"])))
			)));
		
		include("populateSpecs.jsl");
		eval(eval expr(buthb<<append(ButtonBox("Save Param",
			setAxis(expr(colname),expr(rno));
			specsToTable(htab,expr(dtLimits),expr(colname));
		))));
		
		// Add in the Spec limit fields
		slob<<append(limshb=H List Box());
		(::pdicts[rno][colname]["graph"]<<report())<<set title(colname);
		(::pdicts[rno][colname]["graph"]<<report())<<set auto stretching(0,0);
		
		limshb<<append(TextBox("<b> LSL:  </b>",<<Markup(1)));
		eval(eval expr(limshb<<append(
			::pdicts[rno][expr(colname)]["lslbox"]=NumberEditBox(::pdicts[expr(rno)][expr(colname)]["LSL"],10,
				<<Set Function(Function({},{},
					lslboxChanged(expr(colname),expr(rno));
					reSpec(expr(colname),expr(rno));
					Show("After box changed.");
					))))));
		limshb<<append(TextBox("<b>  USL:  </b>",<<Markup(1)));
		eval(eval expr(limshb<<append(
			::pdicts[expr(rno)][expr(colname)]["uslbox"]=NumberEditBox(::pdicts[expr(rno)][expr(colname)]["USL"],10,
				<<Set Function(Function({},{},
					uslboxChanged(expr(colname),expr(rno));
					reSpec(expr(colname),expr(rno));
					))))));
		
		// Add in the CPK fields
		slob<<append(cpkhb=H List Box());
		cpkhb<<append(TextBox("<b> Mean:  </b>",<<Markup(1)));
		eval(eval expr(cpkhb<<append(
			::pdicts[expr(rno)][expr(colname)]["meanbox"]=
				TextBox("Hit Calc";))));
		cpkhb<<append(TextBox("<b>  CPL:  </b>",<<Markup(1)));
		eval(eval expr(cpkhb<<append(
			::pdicts[expr(rno)][expr(colname)]["cplbox"]=
				TextBox("Hit Calc";))));
		cpkhb<<append(TextBox("<b>  CPU:  </b>",<<Markup(1)));
		eval(eval expr(cpkhb<<append(
			::pdicts[expr(rno)][expr(colname)]["cpubox"]=
				TextBox("Hit Calc";))));
		slob<<append(medhb=HListBox());
		
		// Get the median from an invisible stats table
		eval(eval expr(
		t=htab<<Tabulate(
			Show Control Panel( 0 ),
			Add Table(
				Column Table( Analysis Columns( expr(column(htab,colname) ) ) ),
				Row Table( Statistics( Median) )
			),
			<<MakeIntoDataTable(Invisible(1),OutputTable("Stats"))
		)));
		med=Column(DataTable("Stats"),colname)[1];
		t<<Close Window();
		Close("Stats",NoSave);
		medhb<<append(TextBox("<b> Unfiltered Median:  </b>"||Format(med,"Best",7),<<Markup(1),<<SetWidth(200)));
		
		// Add the hold scales button
		eval(eval expr(buthb<<append(ButtonBox("Hold Scales",setAxis(expr(colname),expr(rno))))));
		
		// Add a Data Filter and put a RECALC CPK button inside it.
		eval(eval expr(guibox<<append(
			datfilt=htab<<DataFilter(Filter Columns(expr(colname)),Set Select(0),Set Show(1),Set Include(1)))));
		((datfilt<<report)[OutlineBox(1)])<<OutlineCloseOrientation(Horizontal) <<Close;
		eval(eval expr(guibox[ButtonBox(8)]
			<<Sib Append(ButtonBox("RECALC CPK",updateCPKrow(expr(colname),expr(rno));))));
		
		// Do the CPK Calculations
		updateCPKRow(colname,rno);
	);

);

// Update the limit in pdicts from the value in the box
lslboxChanged=Function({colname,rno},{Default Local},
	newlsl=::pdicts[rno][colname]["lslbox"] <<get();
	::pdicts[rno][colname]["LSL"]=newlsl;
);
uslboxChanged=Function({colname,rno},{Default Local},
	newusl=::pdicts[rno][colname]["uslbox"] <<get();
	::pdicts[rno][colname]["USL"]=newusl;
);

// Update the spec limits in the table properties
reSpec=Function({colname,rno},{Default Local},
	
	setAxis(colname,rno);
	newprops= eval expr({
			LSL(expr(::pdicts[rno][colname]["LSL"])),
			USL(expr(::pdicts[rno][colname]["USL"])),
			TARGET(.),
			Show Limits(1),
			Add Ref Line(expr(::pdicts[rno][colname]["LSL"]),0,5,"LSL");
			Add Ref Line(expr(::pdicts[rno][colname]["USL"]),0,5,"USL");
	});
	htab=::pdicts[rno]["htab"];
	column(htab,colname)<<Delete Property("Spec Limits");
	eval(eval expr(column(htab,colname)<<Set Property("Spec Limits",expr(newprops))));
	column(htab,concat(colname,"_FAILBOOL")) <<EvalFormula();
	column(htab,concat(colname,"_FAILPCT")) <<EvalFormula();
	
	updateCPKrow(colname,rno);
);

// Update the axis limits in the table properties so the graphics doesn't revert them
setAxis=Function({colname,rno},{Default Local},
	((::pdicts[rno][colname]["graph"]<<report)[axis box(3)])<<Save To Column Property;
	
	col=column(::pdicts[rno]["htab"],colname);
	
	ax script=((::pdicts[rno][colname]["graph"]<<report)[axis box(3)])<<Get Script;
	clean ax script={};
	for (a=1, a<=n items(ax script), a+=1,
		if (headname(ax script[a])!="Add Ref Line",
			clean ax script[N Items(clean ax script)+1]=ax script[a];
			);
	);
	eval(eval expr(col<< Set Property("Axis", expr(clean ax script))));
	
);

// Runs the CPK Calculation
updateCPKrow=Function({colname,rno},{Default Local},
	Write("Updating CPK\!N");
	col=column(::pdicts[rno]["htab"],colname);
	
	Summarize(mu=Mean(col),sigma=Std Dev(col));
	
	cpu=(::pdicts[rno][colname]["USL"]-mu)/(3*sigma);
	cpl=(mu-::pdicts[rno][colname]["LSL"])/(3*sigma);
	
	::pdicts[rno][colname]["meanbox"]<<set text(Format(mu,"Best",7));
	::pdicts[rno][colname]["cplbox"]<<set text(char(round(cpl,3)));
	::pdicts[rno][colname]["cpubox"]<<set text(char(round(cpu,3)));
);
