// Use the local namespace
Names Default To Here(1);

// Creates the graphical window showing the variability report
generateVariabilityReport=Function({run},{Default Local},

	// Short names for some later used variables
	splitCE=::rundicts[run]["centeredge"];
	htab=::rundicts[run]["htab"];
	params=::rundicts[run]["whichparams"];
	
	// If special analysis, then open a column dialog for the user to vary the analysis
	If(::rundicts[run]["specialanalysis"],
	
		// Give the usual X and X Grouping variables as default
		cd = Column Dialog(
			xvars = ColList("X Variables",Columns(:WAFER)),
			xgroupers =  ColList("X Grouping",Columns(:LOT_ID)),
		);
		
		// After the user makes a selection, collect it.
		xvars=cd["xvars"];
		xgroupers=cd["xgroupers"];
		
		,
		// Otherwise (ie not special analysis), just use the default variables
		xvars= List(:WAFER);
		xgroupers= List(:LOT_ID);
	);
	
	// Create the window
	win=New Window("Variability, Run "||Char(run), vb=V List Box());
	
	// When the report is closed, it should also
	// - note this in the log
	// - close the two data tables (and not throw an error if they're already closed)
	// - empty out this entry from rundicts
	eval(eval expr(
		win<<On Close(
			Write("Closing Run "||Char(run)||".\!N");
			Try(Close(::rundicts[expr(run)]["htab"],No Save));
			Try(Close(::rundicts[expr(run)]["dtLimits"],No Save));
			::rundicts[expr(run)]=.;
			);
	));	
	
	// For each parameter
	For( p=1, p<=N Items(params), p+=1,	
		param=params[p];
		fail_param=Concat(param,"_FAILPCT");
		
		// The next blocks of code will format the (possible varied) x and y variables into a single
		// expression for the Graph Builder's "Variables"" argument.
		// A typical outcome of this chunk of code might be:
		// varexpr =
		//  Variables(
		//		X(:WAFER, Position(1)),
		//		Y(Column(htab, "N.18X5_BF@.6V_FAILPCT")),
		//		Y(Column(htab, "N.18X5_BF@.6V_FAILPCT edge"), Position(1)),
		//		Y(Column(htab, "N.18X5_BF@.6V_FAILPCT center"), Position(1)),
		//		Y(Column(htab, "N.18X5_BF@.6V")),
		//		Y(Column(htab, "N.18X5_BF@.6V edge"),Position(2)),
		//		Y(Column(htab, "N.18X5_BF@.6V center"), Position(2))
		// 		Group X(:LOT_ID,
		//			Order By(:NumericDate, Ascending, Order Statistic("Mean")), Show Title(0)));
		varexpr=expr(Variables());
		
		// First put in each X variable
		for(i=1, i<=n items(xvars),i+=1,
			insertinto(varexpr,eval expr( X(expr(xvars[i]),Position(1)))));
		
		// Put in the failure columns and parameter columns
		insertinto(varexpr,eval expr(Y(column(htab,expr(fail_param)))));
		insertinto(varexpr,eval expr(Y(column(htab,expr(fail_param||" edge")),Position(1))));
		insertinto(varexpr,eval expr(Y(column(htab,expr(fail_param||" center")),Position(1))));
		insertinto(varexpr,eval expr(Y(column(htab,expr(param)))));
		insertinto(varexpr,eval expr(Y(column(htab,expr(param||" edge")),Position(2))));
		insertinto(varexpr,eval expr(Y(column(htab,expr(param||" center")),Position(2))));
		
		// Put in each X Grouping variable, 
		// noting that LOT_ID and PCM_SPEC should be chronologically ordered
		for(i=1, i<=n items(xgroupers), i+=1,
		
			// If it's one of those that needs to be ordered
			if( ((xgroupers[i]<<Get Name)=="LOT_ID") | ((xgroupers[i]<<Get Name)=="PCM_SPEC"),
			
				// Include the ordering info
				insertinto(varexpr,
					eval expr(Group X(expr(xgroupers[i]),
						Order By( :NumericDate, Ascending, Order Statistic( "Mean" ) ),
						Show Title( 0 ) ))),
				
				// Otherwise just put it in plain
				insertinto(varexpr,
					eval expr(Group X(expr(xgroupers[i])))))
		);
		
		// Create an expression that would build the graph
		vargraph=eval expr(
			Graph Builder(
				
				// Size of graph from rundicts
				expr(::rundicts[run]["graphsize"]),
				
				// Hide control panel
				Show Control Panel( 0 ),
				
				// Whether to show legend from rundicts
				Show Legend( expr(::rundicts[run]["showlegend"]) ),
				
				// Put the X Groups along the bottom of the plot
				X Group Edge( "Bottom" ),
				
				// Variables from expression built above
				expr(name expr(varexpr)),
				
				// Relative sizing of top and bottom plots
				Relative Sizes( "Y", [1 3] ),
				
				// Elements of top (failure) plot
				Elements(
					Position( 1, 1 ),
					
					// Two lines if center-edge split, else one line
					expr(If(splitCE,
						expr(Line(X,Y(2),Y(3),Legend( 8 ),Row order( 0 ),Summary Statistic( "Mean" )))
						,
						expr(Line(X,Y(1),Legend( 8 ),Row order( 0 ),Summary Statistic( "Mean" )))
					))
				),
				
				// Elements of bottom (values) plot
				Elements(
					Position( 1, 2 ),
					
					// Two points-plots if center-edge split, else one line
					expr(If(splitCE,
						expr(Points( X, Y(2), Y(3), Legend( 1 ), Jitter( 1 ) )),
						expr(Points( X, Y(1), Legend( 1 ), Jitter( 1 ) )),
					)),
					
					// Two box-plots if center-edge split, else one line
					expr(If(splitCE,
						expr(Box Plot(X,Y(2),Y(3),Legend( 6 ),Jitter( 1 ),Outliers( 0 ),Box Style( "Outlier" ))),
						expr(Box Plot(X,Y(1),Legend( 6 ),Jitter( 1 ),Outliers( 0 ),Box Style( "Outlier" )))	
					)),
					
					// Lines through the mean/median of data if indicated in rundicts
					expr(If(Not(::rundicts[run]["tracklines"]=="None"),
						If(splitCE,
							eval expr(Line(X, Y( 2 ),	Y( 3 ),	Legend( 9 ),Row order( 0 ),
								Summary Statistic( expr(::rundicts[run]["tracklines"]) ))),
							eval expr(Line(X, Y( 1 ),	Legend( 9 ),Row order( 0 ),
								Summary Statistic( expr(::rundicts[run]["tracklines"]) )))
						),
						.
					))
				),
				
				// Send various tweaks to the plots
				SendToReport(
				
					// Format the failure chart
					Dispatch(
						{},
						expr(fail_param),
						ScaleBox,
						{Format( "Percent", 10, 0 ), 
						Minor Ticks( 1 ), Show Major Grid( 1 ), Show Minor Ticks( 0 ), Inside Ticks( 1 )}
					),
					
					// Title the failure plot
					Dispatch( {}, "Y title", TextEditBox, {Set Text( "Failure rate" )} ),
					
					// Title the overall graph
					Dispatch( {}, "graph title", TextEditBox, {Set Text( "Variability Plot" )} ),
					
					// Title the values plot with the parameter name
					Dispatch( {}, "Y 1 title", TextEditBox, {Set Text( expr(param) )} ),
					
					// Choose a good format for the numbers on the axis
					Dispatch( {}, expr(param), ScaleBox, {Format("Best")}),
					
					// Remove the unneeded title from the X-axis
					Dispatch( {}, "X title", TextEditBox, {Set Text( "" )} ),
					
					// Change the mean/median lines color to match the points colors
					expr(If(Not(::rundicts[run]["tracklines"]=="None"),
						If(splitCE,
							expr(Dispatch(
							{},
							"400",
							ScaleBox,
							{Legend Model(
								9,
								Properties( 0, {Line Color( 21 )} ),
								Properties( 1, {Line Color( 19 )} )
							)})),
							expr(Dispatch(
								{},
								"400",
								ScaleBox,
								{Legend Model( 9, Properties( 0, {Line Color( 0 )} ) )}
							))
						)))
				)
			)
		);
		
		// Build the graph, set preferences, and store a reference to it in rundicts
		eval(eval expr(vb<<append(graph=expr(name expr(vargraph)))));
		(graph<<report())<<set title(param);
		(graph<<report())<<set auto stretching(0,0);
		::rundicts[run]["pdict"][param]["graph"]=graph;
		
		// Apply the axis properties from rundicts to the axis
		Rundicts To Axis(run,param);
		
		// Make sure the failure plot is up-to-date
		Update Failures(run,param);
				
		// Build the addtional interface below
		// guibox holds everything
		(graph<<report())<<append(guibox=HListBox());
		
		// slob [Spec Limits Outline Box] holds the various spec limits - related things
		guibox<<append(slob=OutlineBox("Spec Limits",<<OutlineCloseOrientation(Horizontal)));
		
		// limshb, within slob, holds the limit controls
		slob<<append(limshb=H List Box());
		
		// buthb, within slob, holds the slider checkbox, the Recalc CPK button, and the Save button
		slob<<append(buthb=H List Box(Align(Center)));
		
		// Sliders checkbox, calls Toggle Sliders whenever changed
		eval(eval expr(buthb<<append(::rundicts[run]["pdict"][param]["slidercheck"]=
			CheckBox("Show Sliders", Toggle Sliders(expr(run),expr(param))))));
		
		// If default to sliders, then set to checked, and call Toggle Sliders
		If(::rundicts[run]["defaulttosliders"],
			(::rundicts[run]["pdict"][param]["slidercheck"])<<Set(1);
			ToggleSliders(run,param)
		);
		
		// Add the RecalcCPK buton, which calls Recalc CPK whenever pressed
		eval(eval expr(buthb<<append(
			ButtonBox("Recalc CPK", RecalcCPK(expr(run),expr(param))))));
			
		// Add the Save button, which calls Save Param whenever pressed
		eval(eval expr(buthb<<append(ButtonBox("Save Param",
			Save Param(expr(run),expr(param))))));
		
		// Append a textbox saying LSL in bold
		limshb<<append(TextBox("<b> LSL:  </b>",<<Markup(1)));
		
		// Append a number edit box for the LSL which, whenever changed, updates the LSL in rundicts and calls User Changed Spec Limits
		eval(eval expr(limshb<<append(
			::rundicts[expr(run)]["pdict"][expr(param)]["lslbox"]=NumberEditBox(::rundicts[expr(run)]["pdict"][expr(param)]["LSL"],10,
				<<Set Function(Function({},{},
					::rundicts[expr(run)]["pdict"][expr(param)]["LSL"]=::rundicts[expr(run)]["pdict"][expr(param)]["lslbox"] <<get();
					User Changed Spec Limits(expr(run),expr(param))))))));
		
		// Append a textbox saying USL in bold			
		limshb<<append(TextBox("<b>  USL:  </b>",<<Markup(1)));
		
		// Append a number edit box for the USL which, whenever changed, updates the USL in rundicts and calls User Changed Spec Limits
		eval(eval expr(limshb<<append(
			::rundicts[expr(run)]["pdict"][expr(param)]["uslbox"]=NumberEditBox(::rundicts[expr(run)]["pdict"][expr(param)]["USL"],10,
				<<Set Function(Function({},{},
					::rundicts[expr(run)]["pdict"][expr(param)]["USL"]=::rundicts[expr(run)]["pdict"][expr(param)]["uslbox"] <<get();
					User Changed Spec Limits(expr(run),expr(param))))))));
		
		
		// Get the valid low and valid high from rundicts; if they're missing, then use the min and max of the data
		lvl=::rundicts[run]["pdict"][param]["LVL"];
		uvl=::rundicts[run]["pdict"][param]["UVL"];
		If(Is Missing(lvl), lvl=Col Minimum(Column(::rundicts[run]["htab"],param)));
		If(Is Missing(uvl), uvl=Col Maximum(Column(::rundicts[run]["htab"],param)));
		
		// Add a data filter, using the just obtained values as the default limits,
		// and store a reference to it in rundicts
		// Also, tell JMP that when the filter is closed, it should close horizontally for aesthetic reasons
		eval(eval expr(guibox<<append(
			datfilt=htab<<DataFilter(
			Set Select(0),Set Show(1),Set Include(1),
			<<Add Filter(
				columns(expr(param)),
				where(And(
					as column(expr(param))>=expr(lvl),
					as column(expr(param))<=expr(uvl)
					))
		)))));
		::rundicts[run]["pdict"][param]["datfilt"]=datfilt;
		((datfilt<<report)[OutlineBox(1)])<<OutlineCloseOrientation(Horizontal);
		
		// cpkhb holds the CPK-related fields
		slob<<append(cpkhb=H List Box());
		
		// Add in the various text labels and text boxes for the CPK items
		cpkhb<<append(TextBox("<b> Mean:  </b>",<<Markup(1)));
		eval(eval expr(cpkhb<<append(
			::rundicts[expr(run)]["pdict"][expr(param)]["meanbox"]=
				TextBox("Hit Recalc";))));
		cpkhb<<append(TextBox("<b>  CPL:  </b>",<<Markup(1)));
		eval(eval expr(cpkhb<<append(
			::rundicts[expr(run)]["pdict"][expr(param)]["cplbox"]=
				TextBox("Hit Recalc";))));
		cpkhb<<append(TextBox("<b>  CPU:  </b>",<<Markup(1)));
		eval(eval expr(cpkhb<<append(
			::rundicts[expr(run)]["pdict"][expr(param)]["cpubox"]=
				TextBox("Hit Recalc";))));
				
		// Run the calculation for CPK
		RecalcCPK(run,param);
		
		// Get the unfiltered data median from an invisible stats table
		// Close the invisible table and associated extraneous window
		// Add the median field to medhb and add medhb to slob
		eval(eval expr(
		t=htab<<Tabulate(
			Show Control Panel( 0 ),
			Add Table(
				Column Table( Analysis Columns( expr(column(htab,param) ) ) ),
				Row Table( Statistics( Median) )
			),
			<<MakeIntoDataTable(Invisible(1),OutputTable("Stats"))
		)));
		med=Column(DataTable("Stats"),param)[1];
		t<<Close Window();
		Close("Stats",NoSave);
		slob<<append(medhb=HListBox());
		medhb<<append(TextBox("<b> Unfiltered Median:  </b>"||Format(med,"Best",7),<<Markup(1),<<SetWidth(200)));
		
		// Script for the graphical handles (I call them "sliders") on the spec limits
		::rundicts[run]["pdict"][param]["script"]=eval expr(
		
			// Start the LSL handlle at position (.5, LSL from rundicts)
			Handle( .5, ::rundicts[expr(run)]["pdict"][expr(param)]["LSL"],
			
				// Script for "as the mouse drags":
				// Purely aesthetic, adjust the LSL in rundicts so the handle moves along with the mouse
				Try(::rundicts[expr(run)]["pdict"][expr(param)]["LSL"]=y;)
				,
				// Script for "when the mouse releases":
				// Update the LSL in rundicts and in the text box, then call User Changed Spec limits
				// If there's an error (JMP has some race-condition bug here...), wait a sec and try again.
				Try(
					::rundicts[expr(run)]["pdict"][expr(param)]["LSL"]=y;
					::rundicts[expr(run)]["pdict"][expr(param)]["lslbox"] <<set(y);
					User Changed Spec Limits(expr(run),expr(param));
					,					
					Try(
						Write("Graphics Error.\!N");
						Wait(1);
						::rundicts[expr(run)]["pdict"][expr(param)]["LSL"]=y;
						::rundicts[expr(run)]["pdict"][expr(param)]["lslbox"] <<set(y);
						User Changed Spec Limits(expr(run),expr(param));
						Write("Recovered\!N");,
						Write("Couldn't Recover\!N");
					);
				)
			);
			
			// Same stuff for the USL handle
			Handle( .5,::rundicts[expr(run)]["pdict"][expr(param)]["USL"],
				Try(::rundicts[expr(run)]["pdict"][expr(param)]["USL"]=y;)
				,
				Try(
					::rundicts[expr(run)]["pdict"][expr(param)]["USL"]=y;
					::rundicts[expr(run)]["pdict"][expr(param)]["uslbox"] <<set(y);
					User Changed Spec Limits(expr(run),expr(param));
					,
					Try(
						Write("Graphics Error.\!N");
						Wait(1);
						::rundicts[expr(run)]["pdict"][expr(param)]["USL"]=y;
						::rundicts[expr(run)]["pdict"][expr(param)]["uslbox"] <<set(y);
						User Changed Spec Limits(expr(run),expr(param));
						Write("Recovered\!N");,
						Write("Couldn't Recover\!N");
					);
				)
			);
		);
	);
);

// Below are various functions that move information around to keep things updated and consistent.

// Save values to dtLimits
Save Param=Function({run,param},{Default Local},

	// Make sure rundicts is up-to-date with respect to the axis and data filter
	Axis to rundicts(run,param);
	Filter to rundicts(run,param);
	
	// Short name for the relevant parameter dictionary
	pd=::rundicts[run]["pdict"][param];
	
	// Ensure that dtLimits is open, and write in all our data
	dtLimits=Open(::scriptdir||::rundicts[run]["dtLimits path"],Private);
	r=pd["row"];
	Column(dtLimits,"AXIS_SCALE")[r]=pd["SCALE"];
	Column(dtLimits,"AXIS_LOW")[r]=pd["LAL"];
	Column(dtLimits,"AXIS_HIGH")[r]=pd["UAL"];
	Column(dtLimits,"SPEC_LOW")[r]=pd["LSL"];
	Column(dtLimits,"SPEC_HIGH")[r]=pd["USL"];
	Column(dtLimits,"VALID_LOW")[r]=pd["LVL"];
	Column(dtLimits,"VALID_HIGH")[r]=pd["UVL"];
	Column(dtLimits,"AXIS_INC")[r]=pd["INC"];
	
	// Save dtLimits
	dtLimits<<Save;
);

// Runs the CPK Calculation and updates the CPK fields
RecalcCPK=Function({run,param},{Default Local},
	Write("Updating CPK\!N");
	
	// Use the summarize function to get the relevant column statistics
	col=column(::rundicts[run]["htab"],param);
	Summarize(mu=Mean(col),sigma=Std Dev(col));
	
	// Calculate values
	cpu=(::rundicts[run]["pdict"][param]["USL"]-mu)/(3*sigma);
	cpl=(mu-::rundicts[run]["pdict"][param]["LSL"])/(3*sigma);
	
	// Update fieds
	::rundicts[run]["pdict"][param]["meanbox"]<<set text(Format(mu,"Best",7));
	::rundicts[run]["pdict"][param]["cplbox"]<<set text(char(round(cpl,3)));
	::rundicts[run]["pdict"][param]["cpubox"]<<set text(char(round(cpu,3)));
);

// Adds or removes the draggable handles to/from the graph when the checkbox is changed
Toggle Sliders=Function({run,param},{Default Local},

	// If checkbox is "yes"...
	If(::rundicts[run]["pdict"][param]["slidercheck"]<<Get(),
		// add the graphics script
		eval(eval expr(((::rundicts[run]["pdict"][param]["graph"] << report)[Frame Box(2)])
			<<Add Graphics Script(expr(::rundicts[run]["pdict"][param]["script"]))));
		,
		// otherwise, remove the graphics script
		((::rundicts[run]["pdict"][param]["graph"] << report)[Frame Box(2)])<<Remove Graphics Script(1);
	)
);

// Runs the various other update functions to ensure consistency across the interface when spec limits get changed
User Changed Spec Limits=Function({run,param},{Default Local},
	Write("Changing spec lims\!N");
	Axis To rundicts(run,param);
	rundicts To Axis(run,param);
	Update Failures(run,param);
	RecalcCPK(run,param);
);

// Applies releveant properties from rundicts to the axis
Rundicts To Axis=Function({run,param},{Default Local},

	// Expression of the properties
	props to axis=eval expr({
		Min(expr(::rundicts[run]["pdict"][param]["LAL"])),
		Max(expr(::rundicts[run]["pdict"][param]["UAL"])),
		Inc(expr(::rundicts[run]["pdict"][param]["INC"])),
		Scale(expr(::rundicts[run]["pdict"][param]["SCALE"]))
	});	
	
	// If ref lines are desired, add them in as well
	If(::rundicts[run]["showreflines"],
		insert into(props to axis,
			eval expr(Add Ref Line(expr(::rundicts[run]["pdict"][param]["USL"]), Solid, "Black", "USL", 1)));
		insert into(props to axis,
			eval expr(Add Ref Line(expr(::rundicts[run]["pdict"][param]["LSL"]), Solid, "Black", "LSL", 1)));
	);
	
	// Send the expression to the graph
	eval(eval expr(::rundicts[run]["pdict"][param]["graph"]<<SendToReport(
		Dispatch({}, expr(param), ScaleBox,	expr(props to axis)))));
);

// Reads values from the axis and saves them to rundicts
Axis to Rundicts=Function({run,param},{Default Local},

	// Get the "axis script", throwing an error if you can't.
	Try(
		ax script=((::rundicts[run]["pdict"][param]["graph"]<<report)[axis box(3)])<<Get Script;,
		Throw("Invalid axis limits for current data!");
	);
	
	// Save values from the axis script into rundicts
	::rundicts[run]["pdict"][param]["LAL"]=ax script["Min"];
	::rundicts[run]["pdict"][param]["UAL"]=ax script["Max"];
	::rundicts[run]["pdict"][param]["INC"]=ax script["Inc"];
	::rundicts[run]["pdict"][param]["SCALE"]=ax script["Scale"];
);

// Reads valid limits from the data filter into rundicts
Filter to Rundicts=Function({run,param},{Default Local},

	// Get the "where clause" from the data filter
	description=(::rundicts[run]["pdict"][param]["datfilt"])<< get where clause;
	//Write(description||"\!N");
	Write("SAM, clear selection\!N");
	
	// Regexes for extracting upper and lower limits from the where clause
	lpat=":(?:Name\( \!")*"||param||"(?:\!" \))* >=+ ([\d\.e\+\-]+)";
	upat=":(?:Name\( \!")*"||param||"(?:\!" \))* <=+ ([\d\.e\+\-]+)";
	
	// Try the regexes.  If they succeed, use the extracted values, otherwise use '.'
	lvlmatch=Regex Match(description,lpat);
	lvl=If(Length(lvlmatch)==2,	Parse(lvlmatch[2]),.);
	uvlmatch=Regex Match(description,upat);
	uvl=If(Length(uvlmatch)==2,	Parse(uvlmatch[2]),.);
	
	// If the extracted values are beyond/equal to the data's extremes, then that direction is just
	// not being filtered, and should be ignored (ie use '.')
	If(lvl<=Col Minimum(Column(::rundicts[run]["htab"],param)),lvl=.);
	If(uvl>=Col Maximum(Column(::rundicts[run]["htab"],param)),uvl=.);
	
	//Write("LVL: "||Char(lvl)||" UVL: "||Char(uvl)||"\!N");
	// Save to rundicts
	::rundicts[run]["pdict"][param]["LVL"]=lvl;
	::rundicts[run]["pdict"][param]["UVL"]=uvl;	
);

// Evaluate all the failure columns (eg after spec limits or filtering have changed), and fix the
// failure plot axis if it got changed.
Update Failures=Function({run,param},{Default Local},
	column(::rundicts[run]["htab"],concat(param,"_FAILBOOL")) <<EvalFormula();
	column(::rundicts[run]["htab"],concat(param,"_FAILPCT")) <<EvalFormula();
	column(::rundicts[run]["htab"],concat(param,"_FAILBOOL center")) <<EvalFormula();
	column(::rundicts[run]["htab"],concat(param,"_FAILPCT center")) <<EvalFormula();
	column(::rundicts[run]["htab"],concat(param,"_FAILBOOL edge")) <<EvalFormula();
	column(::rundicts[run]["htab"],concat(param,"_FAILPCT edge")) <<EvalFormula();
	eval(eval expr(::rundicts[run]["pdict"][param]["graph"]<<SendToReport(
		Dispatch({},
			expr(param||"_FAILPCT"),
			ScaleBox,
			{Min( 0 ), Max( 1 ), Inc( 0.1 )}))));
);