// Use the local namespace
Names Default To Here(1);

// Generates a horizontal data table from which the variability report can be generated.
generateSpecificTable=Function({run,scriptdir},{Default Local},

	// Open the data and limits
	dtLimits=Open("saved_data/"||dataname||".LIMITS.jmp",Private);
	fulltab=Open("saved_data/"||dataname||".jmp",Private);
	
	// Pop-up to determine which parameters to use and whether it's a special analysis
	// default: not special
	if(not(N Items(::pdicts[run]["whichparams"])),
		all params=column(dtLimits,"Parameter")<<Get Values;
		New Window(<<Modal,
			VListBox(
			whichparambox=ListBox(all params)
			,specialanalysisbox=CheckBox("Special Analysis",
				<<Set(::pdicts[run]["specialanalysis"]))
			,CEbox=CheckBox("Separate Center/Edge",
				<<Set(::pdicts[run]["centeredge"]))
			)
		);
		::pdicts[run]["whichparams"]=whichparambox<<Get Selected;
		::pdicts[run]["specialanalysis"]=specialanalysisbox<<Get();
		::pdicts[run]["centeredge"]=CEbox<<Get();
	);
	
	whichparams=::pdicts[run]["whichparams"];
	// If user made no selection, then stop!
	if(not(N Items(whichparams)),
		Write("No parameters selected.\!N");
		Stop();
	);
	
	// Make a table with only the intended parameter
	Write("Generating horizontal data for specific parameters...\!N");
	fulltab<<select where(contains(whichparams,:parameter));
	ptab=fulltab<<subset(selected rows(1),selected columns(0),Private);
	Close(fulltab,No Save);

	// "Split" by parameter so the parameter values become columns.
	phtab=ptab<<
		Split(
			Split By( :PARAMETER ),
			Split( :VALUE ),
			Output Table( "Pre-Join Horizontal" ),
			Remaining Columns( Keep(:WAT_FILE_KEY, :WAFER, :SITE, :XCOORD, :YCOORD ) ),
			Private
		);
	Close(ptab,No Save);

	// Add in limits (and do value invert if necessary)
	Write("Adding Spec Limits\!N");
	
	For(r=1,r<N Rows(dtLimits),r++,
		param=Column(dtLimits,"PARAMETER")[r];
		If(Contains(whichparams,param),
			::pdicts[run][param]=Associative Array();
			
			scale= Column(dtLimits,"AXIS_SCALE")[r];
			lal= Column(dtLimits,"AXIS_LOW")[r];
			ual= Column(dtLimits,"AXIS_HIGH")[r];
			inc= Column(dtLimits,"AXIS_INC")[r];
			
			If(Is Missing(lal),
			eval(eval expr(
				t=phtab<<Tabulate(
					Show Control Panel( 0 ),
					Add Table(
						Column Table( Analysis Columns( expr(column(phtab,param) ) ) ),
						Row Table( Statistics( Median, Interquartile Range ) )
					),
					<<MakeIntoDataTable(Invisible(1),OutputTable("Stats"))
				)));
			med=Column(DataTable("Stats"),param)[1];
			iqr=Column(DataTable("Stats"),param)[2];
			t<<Close Window();
			Close("Stats",NoSave);
			
			lal=med-3*iqr;
			ual=med+3*iqr;
			inc=(ual-lal)/7;
			);
			
			If (Column(dtLimits,"VALUE_INVERT")[r],
				Column(phtab,param)<< Set Values(-1*(Column(phtab,param)<<Get Values));
				lsl = -Column( dtLimits, "SPEC_HIGH" )[r];
				usl = -Column( dtLimits, "SPEC_LOW" )[r];
				,
				lsl = Column( dtLimits, "SPEC_LOW" )[r];
				usl = Column( dtLimits, "SPEC_HIGH" )[r];
			);
			
			lvl= Column(dtLimits,"VALID_LOW")[r];
			uvl= Column(dtLimits,"VALID_HIGH")[r];
			
			
			::pdicts[run][param]["row"]=r;
			::pdicts[run][param]["LSL"]=lsl;
			::pdicts[run][param]["USL"]=usl;
			::pdicts[run][param]["LAL"]=lal;
			::pdicts[run][param]["UAL"]=ual;
			::pdicts[run][param]["INC"]=inc;
			::pdicts[run][param]["SCALE"]=scale;
			::pdicts[run][param]["LVL"]=lvl;
			::pdicts[run][param]["UVL"]=uvl;
		);
	);

	// Add in WAT key data
	Write("Adding WAT Key data\!N");
	dtWAT=Open("saved_data/WAT_Key.jmp",Private);
	htab=dtWAT << Join(
		With( phtab ),
		By Matching Columns( :WAT_FILE_KEY = :WAT_FILE_KEY ),
		Drop multiples( 0, 0 ),
		Name( "Include non-matches" )(0, 0),
		Preserve main table order( 1 ),
		Output Table( "HORIZONTAL" ),
	);
	Close(dtWAT, No Save);
	Close(phtab, No Save);
	
	// Open the splits file if it exists
	splits file="splits\splits.xlsx";
	if(file exists(splits file),
		Write("Found splits file.\!N");
		splittab=Open(
			splits file,
			Open all sheets(1),
			Use for all sheets( 1 ),
			Concatenate Worksheets( 0 ),
			Create Concatenation Column( 0 ),
			Worksheet Settings(
				1,
				Has Column Headers( 1 ),
				Number of Rows in Headers( 1 ),
				Headers Start on Row( 1 ),
				Data Starts on Row( 2 ),
				Data Starts on Column( 1 ),
				Data Ends on Row( 0 ),
				Data Ends on Column( 0 ),
				Replicated Spanned Rows( 1 ),
				Suppress Hidden Rows( 1 ),
				Suppress Hidden Columns( 1 ),
				Treat as Hierarchy( 0 )
			),
			Private
		);

		// Check and list column names
		splittab columns=splittab<<Get Column Names;
		pos full lot=contains(splittab columns,As Name("Full Lot"));
		pos wafer=contains(splittab columns,As Name("Wafer"));
		splittab columns=splittab<<Get Column Names(String);
		hor columns =htab <<Get Column Names (String);
		
		if( not(pos full lot) | not(pos wafer),
			Write("Splits table incorrectly formatted!\!N");,
			
			// Expression to select all the columns in the horizontal table
			select expr = expr( select());
			for(i=1, i<=nitems(hor columns), i+=1,
				insert into(select expr, column(htab,hor columns[i]));
			);
			
			// Expression to select all but the first column in the splits table
			remove from (splittab columns, 1, pos wafer);
			select with expr = expr(select with());
			for(i=1, i<=nitems(splittab columns), i+=1,
				insert into(select with expr, column(splittab,splittab columns[i]));
			);
			
			// And use those to join the tables
			select with expr expr=expr(name expr(select with expr));
			select expr expr=expr(name expr(select expr));
			joinexpr=eval expr(
				newhtab=htab << Join(
					With(splittab),
					By Matching Columns(:LOT_ID = :Full Lot, :WAFER = :Wafer),
					expr(select expr expr),
					expr(select with expr expr),
					Preserve Main Table Order(1),
					Suppress Formula Evaluation(1),
					Include Non Matches(1,0),
					Output Table Name("Joined Horizontal"),
					Invisible
			));
			eval(joinexpr);
			close(htab, No Save);
			htab=newhtab;
		);
		,
		Write("Didn't find splits file.  Proceeding without.\!N");
	);
	
	
	// Create a character column by concatenating the coordinates
	htab << Begin Data Update;
	eval(eval expr(htab << New Column("Coord_CAT", Character,Formula(Char(:XCOORD) || "_" || Char(:YCOORD)),
		Set Property(
			"Map Role",
			Map Role(
				Shape Name Use(
					expr(scriptdir || "wafermaps\" || wafermap || "-Name.jmp"),
					"COORDS"
				)
			)
		)
	)));
	
	
	
	// Get the center-edge wafer map
	include("mapCenterEdge.jsl");
	ce map=::CE Maps[wafermap] ;
	// Turn the map into a formula for a new column
	ce formula=eval expr(if(expr(ce map)[:Coord_CAT],"Edge","Center"));
	eval( eval expr(
		htab<< New Column("ColorMap", Character, Nominal, Formula(name expr(ce formula)))));
	// Use that new column to color the rows
	(htab << Select Where( :ColorMap == "Center"))<<Colors("Red");
	(htab << Select Where( :ColorMap == "Edge"))<<Colors("Blue");
	htab << Clear Select;
	htab << End Data Update;
	
	// Create the relevant columns for center-edge specific plotting
	htab << Begin Data Update;
	For( p=1, p<=N Items(whichparams),p+=1,
		colname=whichparams[p];
		center colname=colname||" center";
		edge colname=colname||" edge";
		
		center formula = eval expr( if(:ColorMap=="Center",ascolumn(expr(colname)),.));
		edge formula = eval expr( if(:ColorMap=="Edge",ascolumn(expr(colname)),.));
		
		htab << New column(
			center colname,
			Formula(nameexpr(center formula))
		);
		htab << New column(
			edge colname,
			Formula(nameexpr(edge formula))
		);
	);
	
	// Create the relevant columns for the failure chart
	Write("Creating Failure columns...\!N");
	// For each parameter
	For( p=1, p<=N Items(whichparams), p+=1,
		// The names for the columns
		colname=whichparams[p];
		failbool_colname=colname||"_FAILBOOL";
		failpct_colname=colname||"_FAILPCT";
				
		// The failbool column: boolean formula, 1 if failure
		eval(eval expr(htab << New Column(
			failbool_colname,
			Formula(
				( ascolumn(expr(colname)) < ::pdicts[expr(run)][expr(colname)]["LSL"])
				|
				( ascolumn(expr(colname)) > ::pdicts[expr(run)][expr(colname)]["USL"]) 	
			)
		)));
		// failbool, but specific to centers
		eval(eval expr(htab << New Column(
			failbool_colname||" center",
			Formula(if(:ColorMap=="Center",ascolumn(expr(failbool_colname)),.))
		)));
		// failbool, but specific to edges
		eval(eval expr(htab << New Column(
			failbool_colname||" edge",
			Formula(if(:ColorMap=="Edge",ascolumn(expr(failbool_colname)),.))
		)));
		
		// The failpct column:
		// failure proportion formula calculated by averaging the boolean column
		// over rows that have the same wafer, lot_id, and pcm_spec
		eval(eval expr(htab << New Column(
			failpct_colname,
			Formula(col mean(ascolumn(expr(failbool_colname)),:WAFER, :LOT_ID, :PCM_SPEC))
		)));
		// failpct, but specific to centers
		eval(eval expr(htab << New Column(
			failpct_colname||" center",
			Formula(col mean(ascolumn(expr(failbool_colname||" center")),:WAFER, :LOT_ID, :PCM_SPEC))
		)));
		// failpct, but specific to edges
		eval(eval expr(htab << New Column(
			failpct_colname||" edge",
			Formula(col mean(ascolumn(expr(failbool_colname||" edge")),:WAFER, :LOT_ID, :PCM_SPEC))
		)));
	);
	
	// Create a NUMERIC TheDate column by parsing the preexisting character Date column
	// So that the lots can be ordered by this numeric value on the x-axis
	htab << New Column("the date", Numeric, Continuous, Format("Best", 12),
		Formula(Parse Date(:DATE, "YYYY-MM-DD")));
	
	// Run those formulas now
	htab << RunFormulas();
	htab << End Data Update;
	::pdicts[run]["htab"]=htab;
	::pdicts[run]["dtLimits"]=dtLimits;
	
	Write("Done generating horizontal table.\!N");
	specialanalysis;
);