// Use the local namespace
Names Default To Here(1);

// Generates a horizontal data table for select parameters from which the variability report can be generated.
generateSpecificTable=Function({run},{Default Local},

	// Where to find the data and limits
	fulldatapath="saved_data/"||dataname||".jmp";
	limpath="saved_data/"||dataname||".LIMITS.jmp";
	
	// Open the full data and limits, keeping the tables private (unaccessible)
	// In fact, all tables opened in this script will be private except the final
	// one used in drawing the report.
	fulltab=Open(fulldatapath,Private);
	dtLimits=Open(limpath,Private);
	
	// If whichparams is empty, show a pop-up to determine what to analyze
	If(not(N Items(::rundicts[run]["whichparams"])),
	
		// The list of parameters is obtained from the limits table
		all params=column(dtLimits,"Parameter")<<Get Values;
		
		// Create the pop-up window, with a vertical list layout
		New Window(<<Modal,
			VListBox(
			
			// Which parameters to use (list box of all params)
			whichparambox=ListBox(all params)
			
			// Whether it's a special analysis (checkbox)
			,specialanalysisbox=CheckBox("Special Analysis",
				<<Set(::rundicts[run]["specialanalysis"]))
				
			// Whether to split center and edge (checkbox)
			,CEbox=CheckBox("Separate Center/Edge",
				<<Set(::rundicts[run]["centeredge"]))
			)
		);
		
		// Once the pop-up closes, read the user's inputs into rundicts
		::rundicts[run]["whichparams"]=whichparambox<<Get Selected;
		::rundicts[run]["specialanalysis"]=specialanalysisbox<<Get();
		::rundicts[run]["centeredge"]=CEbox<<Get();
	);
	
	// We'll be using whichparams a lot--let's give it a short name
	whichparams=::rundicts[run]["whichparams"];
	
	// If user made no selection in the pop-up, then stop!
	// And clear this entry from rundicts.
	if(not(N Items(whichparams)),
		Write("No parameters selected.\!N");
		::rundicts[run]=.;
		Stop();
	);
	
	// Make a table with only the intended parameter,
	// by selecting only rows where the parameter value is in whichparams,
	// then using the subset command.
	// Then close the full table.
	Write("Generating horizontal data for specific parameters...\!N");
	fulltab<<select where(contains(whichparams,:PARAMETER));
	ptab=fulltab<<subset(selected rows(1),selected columns(0),Private);
	Close(fulltab,No Save);

	// Split :VALUE by :PARAMETER into a new table.
	// ie the distinct :PARAMETER names become columns containing the entries from :VALUE
	// Then close the previously made table.
	phtab=ptab<<
		Split(
			Split By( :PARAMETER ),
			Split( :VALUE ),
			Output Table( "Pre-Join Horizontal" ),
			Remaining Columns( Keep(:WAT_FILE_KEY, :WAFER, :SITE, :XCOORD, :YCOORD ) ),
			Group(:WAT_FILE_KEY, :WAFER, :SITE, :XCOORD, :YCOORD),
			Private
		);
	Close(ptab,No Save);

	// Gather the limits from the limits table into rundicts.
	// (This is also where we do the value invert if necessary.)
	Write("Adding Spec Limits\!N");
	
	// Iterate through rows of the limits table
	For(r=1,r<N Rows(dtLimits),r++,
	
		// If the parameter name in this row is in whichparams...
		param=Column(dtLimits,"PARAMETER")[r];
		If(Contains(whichparams,param),
		
			// Create an entry for this parameter in rundicts
			::rundicts[run]["pdict"][param]=Associative Array();
			
			// Read the axis values
			scale= Column(dtLimits,"AXIS_SCALE")[r];
			lal= Column(dtLimits,"AXIS_LOW")[r];
			ual= Column(dtLimits,"AXIS_HIGH")[r];
			inc= Column(dtLimits,"AXIS_INC")[r];
			
			// If axis limits are missing...
			If(Is Missing(lal)|Is Missing(ual),
			
				// Create an invisible statistics table for this parameter's data
				eval(eval expr(
					t=phtab<<Tabulate(
						Show Control Panel( 0 ),
						Add Table(
							Column Table( Analysis Columns( expr(column(phtab,param) ) ) ),
							Row Table( Statistics( Median, Interquartile Range, Min ) )
						),
						<<MakeIntoDataTable(Invisible(1),OutputTable("Stats"))
					)));
				
				// Read out the median, interquartile range, and min
				// then close the stats table and window
				med=Column(DataTable("Stats"),param)[1];
				iqr=Column(DataTable("Stats"),param)[2];
				dmin=Column(DataTable("Stats"),param)[3];
				t<<Close Window();
				Close("Stats",NoSave);
				
				// Calculate some reasonable and round axis values, roughly median+/-3 interquartile ranges.
				order of magnitude inc=10^Round(Log10(iqr));
				inc=Round(iqr/order of magnitude inc)*order of magnitude inc;
				lal=Floor((med-3*iqr)/inc)*inc;
				ual=Ceiling((med+3*iqr)/inc)*inc;
				
				// If there was a problem with that, then don't bother trying to make the values round.
				If(Is Missing(inc),
					lal=med-3*iqr;
					ual=med+3*iqr;
					inc=(ual-lal)/7;
				);
				
				// If all the data is positive, don't let the lower limit be negative
				lal=If(dmin>0, Max(lal,0),lal);
				
			);
			
			// If the limits table says the data should be inverted
			valinv=Column(dtLimits,"VALUE_INVERT")[r];
			If (valinv,
			
				// Then flip the data in this column, and read in the spec limits flipped.
				Column(phtab,param)<< Set Values(-1*(Column(phtab,param)<<Get Values));
				lsl = -Column( dtLimits, "SPEC_HIGH" )[r];
				usl = -Column( dtLimits, "SPEC_LOW" )[r];
				,
				// Else just read the spec limits in normally.
				lsl = Column( dtLimits, "SPEC_LOW" )[r];
				usl = Column( dtLimits, "SPEC_HIGH" )[r];
			);
			
			// Read in the default data filter limits.
			lvl= Column(dtLimits,"VALID_LOW")[r];
			uvl= Column(dtLimits,"VALID_HIGH")[r];
			
			// If the data filter limits are invalid, set to missing.
			If(lvl>=uvl, lvl=.;uvl=.);
			
			// Read in the extra axis details
			mt= Column(dtLimits,"MINOR_TICKS")[r];
			format= Column(dtLimits,"FORMAT")[r];
			
			// Put all of the above into the dictionary for this parameter
			::rundicts[run]["pdict"][param]["LSL"]=lsl;
			::rundicts[run]["pdict"][param]["USL"]=usl;
			::rundicts[run]["pdict"][param]["LAL"]=lal;
			::rundicts[run]["pdict"][param]["UAL"]=ual;
			::rundicts[run]["pdict"][param]["INC"]=inc;
			::rundicts[run]["pdict"][param]["SCALE"]=scale;
			::rundicts[run]["pdict"][param]["LVL"]=lvl;
			::rundicts[run]["pdict"][param]["UVL"]=uvl;
			::rundicts[run]["pdict"][param]["MT"]=mt;
			::rundicts[run]["pdict"][param]["FORMAT"]=format;
			::rundicts[run]["pdict"][param]["VALINV"]=valinv;
			
			// Also record the row number so we remember where to save the limits later
			::rundicts[run]["pdict"][param]["row"]=r;
		);
	);

	// Add in lot-related info which is stored separately in the WAT Key data table,
	// by joining that table with ours, where the :WAT_FILE_KEY column is used to
	// index the join.
	// Then close the previous, lotdata-less, table and the WAT Key data table.
	Write("Adding WAT Key data\!N");
	dtWAT=Open("saved_data/WAT_Key.jmp",Private);
	htabwat=dtWAT << Join(
		With( phtab ),
		By Matching Columns( :WAT_FILE_KEY = :WAT_FILE_KEY ),
		Drop multiples( 0, 0 ),
		Name( "Include non-matches" )(0, 0),
		Preserve main table order( 1 ),
		Output Table Name("Horizontal, Run" || Char(run) )//,
		//Invisible
	);
	Close(dtWAT, No Save);
	Close(phtab, No Save);
	
	// Open the Excel file of splits if it exists
	splits file=::rundicts[run]["splitsfile"];
	If(file exists(splits file),
		Write("Found splits file.\!N");
		splittab=Open(
			splits file,
			Open all sheets(1),
			Use for all sheets( 1 ),
			Concatenate Worksheets( 0 ),
			Create Concatenation Column( 0 ),
			Worksheet Settings(
				1,
				Has Column Headers( 1 ),
				Number of Rows in Headers( 1 ),
				Headers Start on Row( 1 ),
				Data Starts on Row( 2 ),
				Data Starts on Column( 1 ),
				Data Ends on Row( 0 ),
				Data Ends on Column( 0 ),
				Replicated Spanned Rows( 1 ),
				Suppress Hidden Rows( 1 ),
				Suppress Hidden Columns( 1 ),
				Treat as Hierarchy( 0 )
			)//,
			//Private
		);

		// Check to see if it's missing the columns we need for matching...
		splittab columns=splittab<<Get Column Names;
		full lot col num=contains(splittab columns,As Name("Full Lot"));
		wafer col num=contains(splittab columns,As Name("Wafer"));
		
		if( not(full lot col num &  wafer col num),
		
			// If so, let the user know
			Write("Splits table incorrectly formatted!\!N");,
			
			// Otherwise proceed to merge the tables, and close the component tables
			Column(splittab,"Full Lot")<<Set Name("LOT_ID");
			Column(splittab,"Wafer")<<Set Name("WAFER");
			splittab<<Delete Column(Base Lot);
			//Stop();
			htab=htabwat << Join(
					With(splittab),
					By Matching Columns(:LOT_ID = :LOT_ID, :WAFER = :WAFER),
					Merge Same Name Columns,
					Preserve Main Table Order(1),
					Suppress Formula Evaluation(1),
					Include Non Matches(1,0),
					Output Table Name("Joined Horizontal, Run" || Char(run) ),
					Invisible
			);
			Close(htabwat, No Save);
			Close(splittab, No Save);
		);
		,
		// Otherwise, if not splits file found, inform the user.
		Write("Didn't find splits file.  Proceeding without.\!N");
		htab=htabwat;
		htab<<Set Name("Joined Horizontal, Run" || Char(run) );
	);
	
	// We're about to make a bunch of tweaks to the table, so let's warn JMP
	// not to do any intermediate processing (like evaluating formulas)
	// on this table until we're finished!
	htab << Begin Data Update;
	
	// Create a character column by concatenating the coordinates.
	// This column will be used in a look-up to determine whether we are center or edge,
	// and will be the "Shape Name Use" column if we want to plot on a wafer map.
	eval(eval expr(htab << New Column("Coord_CAT", Character,Formula(Char(:XCOORD) || "_" || Char(:YCOORD)),
		Set Property(
			"Map Role", Map Role(Shape Name Use(
				expr(::scriptdir || "wafermaps\" || wafermap || "-Name.jmp"),
				"COORDS")))
	)));
	
	
	// Get the center-edge look-up dictionary for this wafermap
	include("mapCenterEdge.jsl");
	ce map=::CE Maps[wafermap] ;
	
	// Make a new column which just states "center" or "edge" based on the previous column
	eval( eval expr(
		htab<< New Column("ColorMap", Character, Nominal,
			Formula(if(expr(ce map)[:Coord_CAT],"Edge","Center")))));
	
	// Use that new column to color the rows
	(htab << Select Where( :ColorMap == "Center"))<<Colors("Red");
	(htab << Select Where( :ColorMap == "Edge"))<<Colors("Blue");
	htab << Clear Select;
	
	// For each parameter
	For( p=1, p<=N Items(whichparams),p+=1,
		colname=whichparams[p];
		
		// Create a copy of the parameter column that only has values for center sites
		center formula = eval expr( if(:ColorMap=="Center",ascolumn(expr(colname)),.));
		htab << New column(
			colname||" center";,
			Formula(nameexpr(center formula))
		);
		
		// Create a copy of the parameter column that only has values for edge sites
		edge formula = eval expr( if(:ColorMap=="Edge",ascolumn(expr(colname)),.));
		htab << New column(
			colname||" edge",
			Formula(nameexpr(edge formula))
		);
	);
	
	// Create the relevant columns for the failure chart
	Write("Creating Failure columns...\!N");
	
	// For each parameter
	For( p=1, p<=N Items(whichparams), p+=1,
		colname=whichparams[p];
				
		// The failbool column: boolean formula, 1 if failure
		failbool_colname=colname||"_FAILBOOL";
		eval(eval expr(htab << New Column(
			failbool_colname,
			Formula(
				( ascolumn(expr(colname)) < ::rundicts[expr(run)]["pdict"][expr(colname)]["LSL"])
				|
				( ascolumn(expr(colname)) > ::rundicts[expr(run)]["pdict"][expr(colname)]["USL"]) 	
			)
		)));
		
		// failbool, but only for centers
		eval(eval expr(htab << New Column(
			failbool_colname||" center",
			Formula(if(:ColorMap=="Center",ascolumn(expr(failbool_colname)),.))
		)));
		
		// failbool, but only for edges
		eval(eval expr(htab << New Column(
			failbool_colname||" edge",
			Formula(if(:ColorMap=="Edge",ascolumn(expr(failbool_colname)),.))
		)));
		
		// The failpct column:
		// failure proportion formula calculated by averaging the boolean column
		// over rows that have the same wafer, lot_id, and pcm_spec.
		failpct_colname=colname||"_FAILPCT";
		eval(eval expr(htab << New Column(
			failpct_colname,
			Formula(col mean(ascolumn(expr(failbool_colname)),:WAFER, :LOT_ID, :PCM_SPEC))
		)));
		
		// failpct, but only for centers
		eval(eval expr(htab << New Column(
			failpct_colname||" center",
			Formula(col mean(ascolumn(expr(failbool_colname||" center")),:WAFER, :LOT_ID, :PCM_SPEC))
		)));
		
		// failpct, but only for edges
		eval(eval expr(htab << New Column(
			failpct_colname||" edge",
			Formula(col mean(ascolumn(expr(failbool_colname||" edge")),:WAFER, :LOT_ID, :PCM_SPEC))
		)));
	);
	
	// Create a NUMERIC date column by parsing the preexisting character Date column
	// So that the lots can be ordered by this numeric value on the x-axis
	htab << New Column("numeric date", Numeric, Continuous, Format("Best", 12),
		Formula(Parse Date(:DATE, "YYYY-MM-DD")));
	
	// Run those formulas now
	// And let JMP know we're done tweaking the table
	htab << RunFormulas();
	htab << End Data Update;
	
	// Store references to these tables in rundicts for later
	::rundicts[run]["htab"]=htab;
	::rundicts[run]["dtLimits"]=dtLimits;
	
	// Also store the path to the limits table in case we need to re-open it later
	// (Why? Because every run keeps a reference to dtLimits, but each run will close
	// dtLimits when the variability report is closed, so it's possible that another
	// run will close dtLimits, making this run need to reopen it.)
	::rundicts[run]["dtLimits path"]=limpath;
	
	// All done!
	Write("Done generating horizontal table.\!N");
);